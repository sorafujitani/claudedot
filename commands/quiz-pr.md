# PRコード理解度クイズ

PRの変更内容を深く分析し、コードの本質的な理解度を確認する**インタラクティブなクイズセッション**を実施します。

## 重要: 1問ずつ進めるルール

- ✅ **1度に1つの問題のみ**提示する
- ✅ 回答を受け取ったら、正誤判定と詳細な解説を提供する
- ✅ 必要に応じて追加の掘り下げ質問を行う
- ✅ 理解できたら次の問題へ進む
- ❌ 複数の問題を一度に出題しない
- ❌ 答えを先に見せない
- ⚠️ **ヒントは控えめに**: 数回間違えてから方針を提示する

## 数値計算・数式に関する方針

- **数値の正確性は重視しない**: 計算結果の細かい数値が正確でなくても問題なし
- **簡単な数式は許容**: ユーザーが数式で説明する場合は受け入れる
- **意図・結果を中心に質問**: 数式によってどのような結果・意図が実現されているかを確認

---

## 実行フロー

### フェーズ1: 差分分析とクイズ作成

1. **現在のブランチを確認**
   ```bash
   git branch --show-current
   git log --oneline -3
   ```

2. **マージ先ブランチの決定**

   以下の優先順位で自動的にマージ先を決定します：

   **2-1. PRの存在確認**
   ```bash
   gh pr list --head <current-branch> --json number,baseRefName,title
   ```

   **2-2. PRが見つかった場合の処理**

   - **PRが1つの場合**: そのPRのマージ先ブランチ（baseRefName）を使用
     ```
     ✅ PR #123が見つかりました
     マージ先: main
     タイトル: [PRタイトル]

     このPRのマージ先 `main` と比較してクイズを作成します。
     ```

   - **PRが複数の場合**: ユーザーに選択させる
     ```
     ⚠️ 複数のPRが見つかりました：

     1. PR #123: [タイトル1] → main
     2. PR #124: [タイトル2] → develop

     どのPRのクイズを作成しますか？番号を教えてください（1-2）:
     ```

   **2-3. PRが見つからない場合**

   ユーザーに比較先を確認します：
   ```
   ℹ️ 現在のブランチ（<current-branch>）のPRが見つかりませんでした。

   どのブランチと比較しますか？

   1. main（デフォルトブランチ）と比較
   2. 別のブランチを指定する

   選択してください（デフォルト: 1）:
   ```

   - 選択肢1の場合: `main`ブランチと比較
   - 選択肢2の場合: ブランチ名を入力してもらう
     ```
     比較するブランチ名を入力してください:
     ```

3. **差分を取得して分析**

   確定したマージ先ブランチとの差分を取得：
   ```bash
   git diff <target-branch>...<current-branch>
   ```

   - 変更されたファイル一覧を把握
   - 主要な変更内容を理解

4. **クイズカテゴリを特定**
   - **コードの動作**: このコードは何をするのか？
   - **副作用と依存**: 他のコンポーネントへの影響は？
   - **エッジケース**: 境界条件での動作は？
   - **パフォーマンス**: 計算量やメモリ使用の変化は？
   - **設計意図**: なぜこの実装を選んだのか？
   - **リファクタリング**: 変更前と比較した改善点は？
   - **バグリスク**: 潜在的な問題は？
   - **テストカバレッジ**: テストは十分か？

5. **クイズを作成**
   - 各カテゴリから重要な問題を3-7問選定
   - 問題は具体的で、コードを読まないと答えられない内容にする
   - **まず該当コードを提示し、機能や目的を自由記述で答えてもらう**
   - その後、詳細な理解度を確認する選択式の追加質問を行う
   - 難易度を明示する（初級/中級/上級）

---

### フェーズ2: インタラクティブクイズセッション（1問ずつ）

**基本フロー**:

```
ステップ1: コードを提示
  ↓
ステップ2: 「このコードは何を目的としているか」を自由記述で回答してもらう
  ↓
ステップ3: ユーザーが述べた目的と実装を照合
  ├─ 3-1. ユーザーの理解した目的を確認
  ├─ 3-2. AIが実装を確認し、目的と相違している箇所を特定
  └─ 3-3. 相違箇所があれば質問「この部分(コード提示)はどう説明できますか？」
  ↓
ステップ4: AIが実装フローを分析し、インタビュー形式で実装の理解を確認
  ├─ 4-1. 実装の主要なステップを特定（内部処理）
  ├─ 4-2. 1つ目の処理について質問「この部分は何をしていますか？」
  ├─ 4-3. 回答を評価 → 曖昧なら追加質問で明確化
  ├─ 4-4. 2つ目の処理について質問
  ├─ 4-5. 回答を評価 → 曖昧なら追加質問で明確化
  └─ 4-6. すべての主要処理を確認するまで繰り返し
  ↓
ステップ5: 実装全体の理解度を総合評価
  ↓
ステップ6: 具体的な入出力例の確認
  ↓
ステップ7: エラーケースとエッジケースの議論
  ↓
ステップ8: 実装のトレードオフと課題の議論
  ↓
ステップ9: 修正提案とコード改善案
  ↓
ステップ10-11: 問題のまとめと進捗表示
  ↓
次の問題へ
```

**ステップ1: コードの提示方法**:

```markdown
## 問題 [X]/[全問題数]

**カテゴリ**: [コードの動作 / 副作用と依存 / エッジケース / パフォーマンス など]

**難易度**: ⭐️ 初級 / ⭐️⭐️ 中級 / ⭐️⭐️⭐️ 上級

**ファイル**: `path/to/file.ts:行番号`

**変更内容**:
```diff
- 変更前のコード（あれば）
+ 変更後のコード
```

または

**追加されたコード**:
```typescript
[新規追加されたコード全体]
```

---
💬 **質問**: このコードはどのような機能や目的を達成しようとしていますか？
自由に説明してください。
```

**ステップ2: 目的の確認**

ユーザーからの回答を受け取る。

**ステップ3: 目的と実装の照合**

⚠️ **省略判断**: ユーザーが目的を正確に説明できている場合はスキップ可能

AIはユーザーが述べた目的と実際の実装を照合：

**3-1. 相違の有無を判定（内部処理）**

- ユーザーが述べた目的で実装が説明できるか？
- 見落としている重要な処理はあるか？

**3-2. 重要な相違のみ質問**

重要な相違がある場合のみ質問（最大1-2箇所）：

```markdown
💬 **質問**: あなたの説明では「[ユーザーが述べた目的]」とのことでしたが、
以下のコードはどのように説明できますか？

```typescript
[相違している箇所のコード]
```
```

相違がない、または些細な場合は次のステップへ。

**ステップ4: インタビュー形式で実装の理解を確認**

AIがコードを分析し、実装の主要な処理ステップを特定して、1つずつインタビューします。

**4-1. 実装フローの分析（内部処理）**

AIは以下を特定します：
- 主要な処理ステップ（3-7個程度）
- 各ステップで使用されているコードの範囲
- 重要な分岐やエッジケース処理

**4-2. インタビューの開始**

```markdown
それでは、この実装がどのように動作しているか、一緒に確認していきましょう。

【実装フローインタビュー】

まず、このコードを見てください：
```typescript
[1つ目の処理に該当するコード部分を抽出]
```

💬 **質問1/[N]**: この部分は何をしていますか？
```

**4-3. 回答の評価と追加質問**

```markdown
【あなたの回答】
"[ユーザーの回答]"

【評価】
✅ 正確に理解しています / ⚠️ だいたい合っています / ❓ もう少し詳しく確認しましょう

[回答が曖昧な場合]
📌 **追加質問**: 具体的に言うと、[曖昧な部分]はどうなっていますか？
- 例: この変数はどこから来ていますか？
- 例: この条件分岐は何をチェックしていますか？

⚠️ **ヒントの方針**:
- 1-2回目の誤答: ヒントなしで再度考えてもらう
- 3回目以降の誤答: 方針や着目点を提示

[数値計算・数式の場合]
✅ 数式の意図・結果が理解できていればOK（細かい数値の正確性は不問）
💬 「この数式でどのような結果を実現していますか？」と意図を確認

[回答が明確な場合]
✅ その通りです！[正確な説明]

次の処理に進みます。
```

**4-4～4-5. すべての主要処理を確認（簡略化可能）**

⚠️ **省略判断**: ユーザーの理解度が高い場合、すべてのステップを質問する必要はない
- ✅完全理解が続いている場合: 残りのステップは簡潔に確認または省略
- ⚠️/❌が出た場合: 該当ステップのみ詳しく確認

すべてのステップについて4-2～4-3を繰り返し、各質問で以下を確認：
- 何をしているか、なぜそうしているか、どう動作するか

**4-6. インタビューのまとめ**

```markdown
【実装フローインタビュー完了】

確認した処理ステップ：
1. [ステップ1の要約] - ✅ 理解度: 完全 / ⚠️ 部分 / ❓ 要復習
2. [ステップ2の要約] - ✅ 理解度: 完全 / ⚠️ 部分 / ❓ 要復習
3. [ステップ3の要約] - ✅ 理解度: 完全 / ⚠️ 部分 / ❓ 要復習
...

全体的な実装理解度: [X/N ステップを完全理解]
```

**ステップ5: 実装全体の総合評価**

```markdown
【実装の総合理解度評価】

**目的の理解**: ✅ 完全理解 / ⚠️ 部分理解 / ❓ 要復習
[コメント]

**実装フローの理解**: [X/N ステップを完全理解]
- 完全に理解できている処理: [ステップ番号]
- 部分的に理解できている処理: [ステップ番号]
- 要復習の処理: [ステップ番号]

**総合評価**: ✅ このコードを十分に理解しています / ⚠️ 基本は理解していますが、いくつか確認が必要です / ❓ もう少し理解を深める必要があります
```

**ステップ6: 具体的な入出力例の確認**

⚠️ **重要な方針**:
- 正常系・異常系・エッジケースを明示的に分けない
- 単発またはミックスで質問し、予測しにくくする
- 「正常系」「エラーケース」などのラベルは一切付けない
- スキップせず、必ず2-4ケース程度は確認する

**パターンA: 単発質問（推奨：シンプルなコードの場合）**

```markdown
💬 **質問**: このコードに以下の入力を与えた場合、どのような出力になりますか？

入力: [具体的な入力値]

どのような出力や動作になると思いますか？
```

回答を受け取り、評価（✅/⚠️/❌）。
- ✅の場合: 簡潔に確認のみ、詳細説明は省略
- ⚠️/❌の場合: 正確な説明を提供

必要に応じて追加の入力例を単発で質問（2-4ケース）。

**パターンB: ミックス質問（推奨：複雑なコードの場合）**

```markdown
💬 **質問**: このコードに以下のような入力を与えた場合、それぞれどのような出力になりますか？

1. 入力: [入力値1]
   - 出力: ？

2. 入力: [入力値2]
   - 出力: ？

3. 入力: [入力値3]
   - 出力: ？

4. 入力: [入力値4]
   - 出力: ？
```

※ケースの順序や種類はランダムに。ラベルなし。

回答を受け取り、各ケースについて評価。
- ✅の場合: 簡潔に確認
- ⚠️/❌の場合: 実際の動作と該当するコード（エラーハンドリング、ガード処理など）を説明

**ステップ8: 実装のトレードオフと課題の議論**

⚠️ **重要な方針**:
- ささいなトレードオフや改善は議論しない
- 重要で影響が大きいもの**のみ**を取り上げる
- 明らかに重要でない観点（例：単純な算術演算のパフォーマンス）はスキップ
- 質問A, B, Cすべてを実施する必要はなし。重要なものだけ

**判断基準**:
- パフォーマンス: N+1問題、O(n²)以上の計算量、大量データ処理など
- 保守性: チーム全体に影響、仕様変更時の修正漏れリスク
- 拡張性: 今後の機能追加を阻害する設計
- セキュリティ: 入力検証漏れ、権限チェック漏れ
- バグリスク: エッジケース未対応、型安全性の欠如

**質問A: 実装のトレードオフ（重要なもののみ）**

```markdown
💬 **質問**: この実装には、どのような**重要な**トレードオフがありますか？

※影響が大きいもののみ回答してください。
※単純な算術演算やシンプルなロジックの場合は「特になし」でOK
```

回答を受け取り、評価。
- 重要でない指摘（例：「早期リターンで少し速くなる」）はスキップ
- 重要な指摘のみ議論

**質問B: 代替案の検討（重要な場合のみ）**

明確に異なる設計がある場合のみ質問：

```markdown
💬 **質問**: 考えられる**明確に異なる**代替案とその選定理由は？

※ささいな実装差（変数名、コメントなど）は除外
```

**質問C: 実装の課題（重要な場合のみ）**

バグリスク、セキュリティ、保守性の問題がある場合のみ質問：

```markdown
💬 **質問**: この実装の**重要な**課題や改善すべき点は？

※バグリスク、セキュリティ、型安全性など影響が大きいもののみ
※コーディングスタイルなどささいな改善は除外
```

**ステップ9: 修正提案とコード改善案**

⚠️ **重要な方針**: 重要度の高い修正提案のみを提示する。ささいな改善は省略。

```markdown
【修正提案とコード改善案】

💬 **質問**: 以下の修正提案について、どう思いますか？実装する価値があると思いますか？

---

## 提案1: [修正/改善のタイトル]

**優先度**: 🔴 高 / 🟡 中 (🟢 低優先度は基本的に省略)

**背景**:
[なぜこの修正が必要か]
- 議論で明らかになった問題: [具体的な問題]
- 影響範囲: [どこに影響するか]

**現在のコード**:
```typescript
[問題のある現在のコード]
```

**提案する修正**:
```typescript
[改善されたコード]
```

**変更点の説明**:
1. [変更点1]: [理由]
2. [変更点2]: [理由]

**期待される効果**:
- ✅ [効果1]
- ✅ [効果2]
- ✅ [効果3]

**トレードオフ**:
- ⚠️ [考慮すべき点1]
- ⚠️ [考慮すべき点2]

**実装の難易度**: ⭐️ 簡単 / ⭐️⭐️ 中程度 / ⭐️⭐️⭐️ 複雑

**推奨**: ✅ 実装を強く推奨 / ⚠️ 検討の価値あり / ℹ️ 任意

---

## 提案2: [修正/改善のタイトル]

[同様の形式で2つ目の提案]

---

## 提案3: [修正/改善のタイトル]

[同様の形式で3つ目の提案]

---

💬 これらの提案について、あなたの意見を聞かせてください：
1. どの提案が最も重要だと思いますか？
2. 実装する際に懸念される点はありますか？
3. 他に改善したい点はありますか？
```

回答を受け取り、フィードバック：

```markdown
【あなたの意見】[ユーザーの回答要約]

【フィードバック】
✅/⚠️ [評価と実装の推奨順序/懸念への回答/追加提案]
```

```markdown
【最終的な修正提案リスト】

## 必須の修正（優先度: 🔴 高）
- [ ] 提案1: [タイトル]
  - 理由: [簡潔な理由]
  - 影響: [影響範囲]
  - 期限: [推奨実装時期]

## 推奨される改善（優先度: 🟡 中）
- [ ] 提案2: [タイトル]
  - 理由: [簡潔な理由]
  - 影響: [影響範囲]

## 任意の改善（優先度: 🟢 低）
- [ ] 提案3: [タイトル]
  - 理由: [簡潔な理由]
  - 影響: [影響範囲]

## 将来的な検討事項
- [ ] [項目1]: [説明]
- [ ] [項目2]: [説明]

**実装時の注意点**:
1. [注意点1]
2. [注意点2]
3. [注意点3]

**関連するテストの追加**:
- [追加すべきテスト1]
- [追加すべきテスト2]

**ドキュメントの更新**:
- [更新すべきドキュメント1]
- [更新すべきドキュメント2]
```

**ステップ10: 問題完了時の詳細レポート保存**

⚠️ **重要**: 問題が完了するたびに、その問題の詳細レポートを **即座にファイル出力** する。
これにより、時間短縮とcontext compaction対策を行う。

⚠️ **簡潔さの原則**:
- ✅評価の場合は詳細説明を省略、要点のみ記録
- ⚠️/❌の場合のみ詳細を記録
- ヒント・方針提示は3回目以降のみ記録

問題完了後、以下のファイルに追記：
- ファイル名: `docs/pr-quiz-result-[YYYY-MM-DD]-[branch-name].md`
- 初回の問題: ファイル作成とヘッダー情報
- 2問目以降: 問題セクションを追記

```markdown
### 問題[X]: [ファイル名:行番号]

**カテゴリ**: [カテゴリ] / **難易度**: ⭐️×[1-3] / **理解度**: ✅/⚠️/❓

**提示コード**: [コード省略可、ファイルパスのみでも可]

**目的理解**:
- あなたの回答: "[要約]"
- 相違箇所: [なし or 簡潔に]

**実装フロー**:
- ✅理解: [ステップリスト]
- ⚠️/❌: [誤解内容と正確な説明]

**入出力例（ミックス）**:
1. 入力[値] → 出力[値]: ✅/⚠️/❌ [コメント]
2. 入力[値] → 出力[値]: ✅/⚠️/❌ [コメント]
※正常/異常/エッジのラベルなし

**重要なトレードオフ・課題のみ**: [なし or 簡潔に]
**修正提案**: [🔴高/🟡中のみ]

---
```

ファイル保存後、コンソールに進捗を表示：

```markdown
✅ 問題[X]完了 - レポート保存済み

📊 進捗: [X/Y問完了] (残りZ問)
✅ 完全理解: Q1, Q3 / ⚠️ 部分理解: Q2 / ⏳ 次: Q[X+1]
📝 修正提案累計: 🔴A個 🟡B個

---

次の問題に進みます...
```

---

### フェーズ3: 最終結果レポート（簡素化）

⚠️ **重要な変更**: 問題ごとに既に詳細レポート保存済み。最後はファイルへのサマリー追記のみ。

すべての問題完了後、既存のレポートファイルの末尾に以下のサマリーを追記：

```markdown
---

# セッション全体のサマリー

## 理解度スコア
**総合**: [X/Y問完全理解] ([%]) - ✅X問 ⚠️Y問 ❌Z問

## 修正提案の統合
**🔴高優先度**: [A個] - [タイトルリスト]
**🟡中優先度**: [B個] - [タイトルリスト]

## 実装ロードマップ
- フェーズ1（緊急1-2日）: [🔴高優先度提案]
- フェーズ2（重要3-5日）: [🟡中優先度提案]

## 次のステップ
1. 🔴高優先度修正の実装
2. 修正後 `/quiz-pr` 再実行または `/pr-qa-review` 実行
3. チーム共有とディスカッション

**セッション情報**: `/quiz-pr` / [時刻]約X分 / 理解度[%] / 提案🔴A🟡B
```

## 実行開始

**手順**: ブランチ確認 → 差分分析・クイズ作成 → **1問ずつ**提示 → 完了後レポート作成
**注意**: 1問ずつ提示、解説提供、進捗表示、ユーザーペース

## 出力形式

**1. 詳細レポート（ファイル）**: `docs/pr-quiz-result-[YYYY-MM-DD]-[branch-name].md`
- 全問題・回答、実装フロー記録、入出力・エラー/エッジケース議論、トレードオフ・課題議論、修正提案詳細、ロードマップ、チェックリスト
- **ユーザー入力は要約**: 長文→要点簡潔化、冗長→簡潔化、キーワード保持

**2. 最終サマリー（コンソール）**:

⚠️ **簡素化**: 問題ごとに詳細出力済みのため、最後は簡潔なサマリーのみ。

```markdown
🎉 PRコードクイズセッション完了！

## セッション結果
- **ブランチ**: [current-branch] → [target-branch]
- **所要時間**: 約X分 / **問題数**: Y問
- **理解度**: ✅X問 ⚠️Y問 ❌Z問 ([%])

## 修正提案
- 🔴 **高優先度**: [A個] - [タイトルリスト]
- 🟡 **中優先度**: [B個] - [タイトルリスト]

## 次のアクション
1. 🔴高優先度修正の実装
2. 修正後 `/quiz-pr` 再実行
3. チーム共有

📄 **詳細レポート**: `docs/pr-quiz-result-[YYYY-MM-DD]-[branch-name].md`
```

## ファイルとコンソール出力の使い分け

**ファイル（詳細）**: ✅全質問回答(要約)、評価、コードスニペット、実装フロー記録、入出力・エラー/エッジケース詳細、トレードオフ分析、修正提案詳細、ロードマップ、チェックリスト、次ステップ
**コンソール（概要）**: ✅セッション情報、理解度スコア、修正提案サマリー、🔴高優先度アクション、🟡中優先度の一部、学習ポイント、詳細リンク、Tips
❌含めない: 詳細回答、長コード、実装フロー詳細、詳細分析、全チェックリスト

## ユーザー入力の記録方法

**要約方針**: 長文(3行以上)→要点1-2行、冗長→簡潔化、キーワード保持、技術用語正確、誤解も記録(AI評価と対比)

**例**:
実際入力: "このコードはユーザーの入力値を検証する機能だと思います。まず、入力値がnullかどうかをチェックして、次に文字列の長さが適切かどうかを確認しています。最後にフォーマットが正しいかどうかを正規表現で検証していると思います。エラーがあれば例外をスローするような実装になっているようです。"
→ 記録: "入力値の検証機能。null チェック、文字列長の確認、正規表現によるフォーマット検証を実施し、エラー時は例外をスロー。"
