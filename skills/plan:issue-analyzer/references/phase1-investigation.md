# Phase 1: Investigation（調査・問題理解）

## 目的

OSSのissueを多角的に調査し、問題の本質と影響範囲を構造化された形で理解する。

## サブエージェント戦略

### 1.1 GitHub Context 取得（URL入力時）

`Task` ツールで `subagent_type: "ctx:github"` エージェントを呼び出す:

```
プロンプト: "{owner}/{repo}#{number} のIssue情報を取得して。
本文、コメント、ラベル、関連PR、Discussionを含めて構造化して返して"
```

返却される構造化コンテキスト（`=== GITHUB_CONTEXT ===` ブロック）から以下を抽出:
- Issue 本文と再現手順
- コメントでの追加情報やメンテナーの反応
- ラベル（bug, enhancement, help wanted 等）
- 関連 PR（過去の修正試行）
- 参照されているファイルパスや関数名

### 1.2 コードベース探索（並列、最大3エージェント）

`Task` ツールで `subagent_type: "Explore"` を最大3並列で起動:

**Agent 1: 問題箇所の特定**
- Issue 内で言及されているファイル名、関数名、エラーメッセージを検索キーワードとして使用
- Grep/Glob でコード内の該当箇所を特定
- コールチェーンを辿り、問題の発生経路を追跡
- 問題箇所の周辺コードを Read で確認

**Agent 2: テスト状況の把握**
- テストディレクトリの構造を Glob で確認（`**/*test*`, `**/*spec*`, `**/test/**`）
- テストフレームワークを package.json, Cargo.toml, go.mod 等から特定
- 問題箇所に対応する既存テストの有無を確認
- テスト実行コマンドを CI 設定（`.github/workflows/`, `Makefile` 等）から特定

**Agent 3: 依存関係の調査**
- 問題箇所が import/require しているモジュールを特定
- 問題箇所を参照している（影響を受ける）下流コードを Grep で特定
- バージョン依存性の確認（特定バージョンで発生する問題の場合）

注意: Issue の内容から問題が明確に局所的な場合は、Agent 1 のみで十分。3並列は複雑な問題の場合に使用する。

### 1.3 公式ドキュメント・外部情報の収集

`WebSearch` で以下を検索:
- 関連する公式ドキュメント、API リファレンス
- 類似 Issue や Stack Overflow の質問
- RFC、仕様書（プロトコルやフォーマットの問題の場合）
- 関連するブログ記事やチュートリアル

`WebFetch` で特に重要なページの詳細内容を取得。

## 出力テンプレート

以下の形式で構造化サマリーを提示する:

```markdown
## Issue 分析サマリー

### 問題定義
- **Issue**: {タイトル} ({URL})
- **問題の本質**: {1文で表現}
- **分類**: [バグ | 機能追加 | パフォーマンス | リファクタリング | セキュリティ]
- **再現条件**: {わかっている場合}

### コードベース分析
- **問題箇所**: `{ファイルパス}:{行番号}` — `{関数/メソッド名}`
- **関連コード**:
  - `{ファイル1}` — {役割}
  - `{ファイル2}` — {役割}
- **依存関係**:
  ```
  [問題箇所] → [依存先1] → [依存先2]
                ↓
              [影響先1]
  ```

### テスト状況
- **テストフレームワーク**: {名前}
- **テスト実行コマンド**: `{コマンド}`
- **既存テストカバレッジ**: {問題箇所に対するテストの有無と内容}

### 公式ドキュメント参照
- [{ドキュメント名}]({URL}) — {該当セクション・要点}

### 未解明の点
- {まだわかっていないこと — Phase 2 で解明を試みる}
```

## 確認ゲート

サマリーを提示した後:
1. 「この分析に認識違いや追加で調査すべき観点はありますか？」と確認
2. ユーザーの「OK」で Phase 2 へ進む
3. 追加調査の要望があれば対応してから再度確認
